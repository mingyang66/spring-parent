### 死磕源码系列【AutoConfigurationImportFilter自动化配置过滤器详解】

```java
/**
 * Filter that can be registered in {@code spring.factories} to limit the
 * auto-configuration classes considered. This interface is designed to allow fast removal
 * of auto-configuration classes before their bytecode is even read.
 * <p>
 * An {@link AutoConfigurationImportFilter} may implement any of the following
 * {@link org.springframework.beans.factory.Aware Aware} interfaces, and their respective
 * methods will be called prior to {@link #match}:
 * <ul>
 * <li>{@link EnvironmentAware}</li>
 * <li>{@link BeanFactoryAware}</li>
 * <li>{@link BeanClassLoaderAware}</li>
 * <li>{@link ResourceLoaderAware}</li>
 * </ul>
 *
 * @author Phillip Webb
 * @since 1.5.0
 */
@FunctionalInterface
public interface AutoConfigurationImportFilter {

	/**
	 * Apply the filter to the given auto-configuration class candidates.
	 * @param autoConfigurationClasses the auto-configuration classes being considered.
	 * This array may contain {@code null} elements. Implementations should not change the
	 * values in this array.
	 * @param autoConfigurationMetadata access to the meta-data generated by the
	 * auto-configure annotation processor
	 * @return a boolean array indicating which of the auto-configuration classes should
	 * be imported. The returned array must be the same size as the incoming
	 * {@code autoConfigurationClasses} parameter. Entries containing {@code false} will
	 * not be imported.
	 */
	boolean[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata);

}
```

AutoConfigurationImportFilter是一个过滤器接口，其实现类是被注册到spring.factories配置文件，被设计用来在自动化配置类字节码加载之前根据条件删除配置类；该接口实现类可以实现org.springframework.beans.factory.Aware接口，可以在match方法被调用之前执行，如：EnvironmentAware、BeanFactoryAware、BeanClassLoaderAware、ResourceLoaderAware

spring.factories配置的实现类如下：

```java
# Auto Configuration Import Filters
org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\
org.springframework.boot.autoconfigure.condition.OnBeanCondition,\
org.springframework.boot.autoconfigure.condition.OnClassCondition,\
org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition
```

从配置中可以看到AutoConfigurationImportFilter接口一共有三个实现类，且三个类都是通过FilteringSpringBootCondition抽象类间接实现AutoConfigurationImportFilter过滤器接口；FilteringSpringBootCondition抽象类是SpringBootCondition类的子类；SpringBootCondition类的作用是提供合理的日志记录以帮助用户诊断加载了哪些类，具体的比对由其子类来实现；

-
SpringBootCondition实现了Condition接口，将一些模板处理定义在该类中，声明了getMatchOutcome这么一个抽象方法，子类只需要实现该方法即可实现业务逻辑，matches方法用于判定其条件是否成立，如果不成立，则会组织该bean的注册

```java
public abstract class SpringBootCondition implements Condition {

	private final Log logger = LogFactory.getLog(getClass());

	@Override
	public final boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
		//获取类名或者方法名（条件注解作用的类或方法上）  
    String classOrMethodName = getClassOrMethodName(metadata);
    //抽象方法，具体子类实现，返回值ConditionOutcome记录了匹配结果boolean和log信息
		ConditionOutcome outcome = getMatchOutcome(context, metadata);
    //打印日志trace级别
		logOutcome(classOrMethodName, outcome);
    //记录结果
		recordEvaluation(context, classOrMethodName, outcome);
		return outcome.isMatch();
	}
  //抽象方法，由子类实现
	public abstract ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata);
		}
```

getClassOrMethodName方法：

```java
//获取类名或者方法名，条件注解可以作用在类上或方法上
private static String getClassOrMethodName(AnnotatedTypeMetadata metadata) {
  //如果metadata是ClassMetadata实例，则返回类名，否则返回全类目#方法名
   if (metadata instanceof ClassMetadata) {
      ClassMetadata classMetadata = (ClassMetadata) metadata;
      return classMetadata.getClassName();
   }
   MethodMetadata methodMetadata = (MethodMetadata) metadata;
   return methodMetadata.getDeclaringClassName() + "#" + methodMetadata.getMethodName();
}
```

getMatchOutcome抽象方法，由子类实现

抽象类的返回结果是ConditionOutcome类型，是对结果boolean和log信息的封装

```java
public class ConditionOutcome {
	//是否匹配
	private final boolean match;
	//消息封住对象，提供了一个流式构造风格
	private final ConditionMessage message;
}	
```

logOutcome方法

```java
	//打印日志，trace级别
	protected final void logOutcome(String classOrMethodName, ConditionOutcome outcome) {
		if (this.logger.isTraceEnabled()) {
			this.logger.trace(getLogMessage(classOrMethodName, outcome));
		}
	}
```

recordEvaluation方法：

```java
//最终将结果记录到缓存之中	
private void recordEvaluation(ConditionContext context, String classOrMethodName, ConditionOutcome outcome) {
		if (context.getBeanFactory() != null) {
			ConditionEvaluationReport.get(context.getBeanFactory()).recordConditionEvaluation(classOrMethodName, this,
					outcome);
		}
	}
```

另外还提供了两个有用的方法供子类使用：

```java
protected final boolean anyMatches(ConditionContext context, AnnotatedTypeMetadata metadata,
      Condition... conditions) {
   for (Condition condition : conditions) {
      if (matches(context, metadata, condition)) {
         return true;
      }
   }
   return false;
}
```

matches方法：

```java
	protected final boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata, Condition condition) {
		if (condition instanceof SpringBootCondition) {
			return ((SpringBootCondition) condition).getMatchOutcome(context, metadata).isMatch();
		}
		return condition.matches(context, metadata);
	}
```

三个过滤器子类OnBeanCondition、OnClassCondition、OnWebApplicationCondition的实现方法都是通过父类中的match方法调用抽象实现方法getOutcomes进行判定是否符合条件；

GitHub地址：[https://github.com/mingyang66/spring-parent](https://github.com/mingyang66/spring-parent)